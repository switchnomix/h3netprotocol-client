/*
 * H3Net Protocol API
 *
 * H3Net Protocol schema with various messages and configurations.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: h3netprotocol@googlegroups.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// FlowMatch : Match fields for flow entries supporting both IPv4 and IPv6
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct FlowMatch {
    #[serde(rename = "in_port", skip_serializing_if = "Option::is_none")]
    pub in_port: Option<i32>,
    #[serde(rename = "eth_src", skip_serializing_if = "Option::is_none")]
    pub eth_src: Option<String>,
    #[serde(rename = "eth_dst", skip_serializing_if = "Option::is_none")]
    pub eth_dst: Option<String>,
    /// Ethernet type (2048 - 0x0800 for IPv4, 34525 - 0x86DD for IPv6)
    #[serde(rename = "eth_type", skip_serializing_if = "Option::is_none")]
    pub eth_type: Option<EthType>,
    /// IP protocol number
    #[serde(rename = "ip_proto", skip_serializing_if = "Option::is_none")]
    pub ip_proto: Option<i32>,
    /// IPv4 source address
    #[serde(rename = "ipv4_src", skip_serializing_if = "Option::is_none")]
    pub ipv4_src: Option<String>,
    /// IPv4 destination address
    #[serde(rename = "ipv4_dst", skip_serializing_if = "Option::is_none")]
    pub ipv4_dst: Option<String>,
    /// IPv6 source address
    #[serde(rename = "ipv6_src", skip_serializing_if = "Option::is_none")]
    pub ipv6_src: Option<String>,
    /// IPv6 destination address
    #[serde(rename = "ipv6_dst", skip_serializing_if = "Option::is_none")]
    pub ipv6_dst: Option<String>,
    /// IPv6 neighbor discovery target address
    #[serde(rename = "ipv6_nd_target", skip_serializing_if = "Option::is_none")]
    pub ipv6_nd_target: Option<String>,
    /// IPv6 neighbor discovery source link-layer address
    #[serde(rename = "ipv6_nd_sll", skip_serializing_if = "Option::is_none")]
    pub ipv6_nd_sll: Option<String>,
    /// IPv6 neighbor discovery target link-layer address
    #[serde(rename = "ipv6_nd_tll", skip_serializing_if = "Option::is_none")]
    pub ipv6_nd_tll: Option<String>,
    /// VLAN ID
    #[serde(rename = "vlan_vid", skip_serializing_if = "Option::is_none")]
    pub vlan_vid: Option<i32>,
    #[serde(rename = "tcp_src", skip_serializing_if = "Option::is_none")]
    pub tcp_src: Option<i32>,
    #[serde(rename = "tcp_dst", skip_serializing_if = "Option::is_none")]
    pub tcp_dst: Option<i32>,
    #[serde(rename = "udp_src", skip_serializing_if = "Option::is_none")]
    pub udp_src: Option<i32>,
    #[serde(rename = "udp_dst", skip_serializing_if = "Option::is_none")]
    pub udp_dst: Option<i32>,
    /// ICMPv6 type
    #[serde(rename = "icmpv6_type", skip_serializing_if = "Option::is_none")]
    pub icmpv6_type: Option<i32>,
    /// ICMPv6 code
    #[serde(rename = "icmpv6_code", skip_serializing_if = "Option::is_none")]
    pub icmpv6_code: Option<i32>,
}

impl FlowMatch {
    /// Match fields for flow entries supporting both IPv4 and IPv6
    pub fn new() -> FlowMatch {
        FlowMatch {
            in_port: None,
            eth_src: None,
            eth_dst: None,
            eth_type: None,
            ip_proto: None,
            ipv4_src: None,
            ipv4_dst: None,
            ipv6_src: None,
            ipv6_dst: None,
            ipv6_nd_target: None,
            ipv6_nd_sll: None,
            ipv6_nd_tll: None,
            vlan_vid: None,
            tcp_src: None,
            tcp_dst: None,
            udp_src: None,
            udp_dst: None,
            icmpv6_type: None,
            icmpv6_code: None,
        }
    }
}
/// Ethernet type (2048 - 0x0800 for IPv4, 34525 - 0x86DD for IPv6)
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum EthType {
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "34525")]
    Variant34525,
}

impl Default for EthType {
    fn default() -> EthType {
        Self::Variant2048
    }
}

