/*
 * H3Net Protocol API
 *
 * H3Net Protocol schema with various messages and configurations.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: h3netprotocol@googlegroups.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PortConfig {
    /// Interface name
    #[serde(rename = "name")]
    pub name: String,
    /// Interface type
    #[serde(rename = "type")]
    pub r#type: Type,
    /// Interface description
    #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Whether the interface is enabled
    #[serde(rename = "enabled")]
    pub enabled: bool,
    #[serde(rename = "ipAddresses", skip_serializing_if = "Option::is_none")]
    pub ip_addresses: Option<Vec<models::IpAddressWithPrefix>>,
    /// MAC address in format XX:XX:XX:XX:XX:XX or XX-XX-XX-XX-XX-XX
    #[serde(rename = "macAddress", skip_serializing_if = "Option::is_none")]
    pub mac_address: Option<String>,
    /// Maximum Transmission Unit
    #[serde(rename = "mtu", skip_serializing_if = "Option::is_none")]
    pub mtu: Option<i32>,
    #[serde(rename = "speed", skip_serializing_if = "Option::is_none")]
    pub speed: Option<models::InterfaceSpeed>,
    /// Interface duplex mode
    #[serde(rename = "duplex", skip_serializing_if = "Option::is_none")]
    pub duplex: Option<Duplex>,
    #[serde(rename = "portId")]
    pub port_id: i32,
    #[serde(rename = "nativeVlan", skip_serializing_if = "Option::is_none")]
    pub native_vlan: Option<i32>,
    #[serde(rename = "aclIn", skip_serializing_if = "Option::is_none")]
    pub acl_in: Option<String>,
    #[serde(rename = "maxLearnedMacs", skip_serializing_if = "Option::is_none")]
    pub max_learned_macs: Option<i32>,
    #[serde(rename = "dynamicVlan", skip_serializing_if = "Option::is_none")]
    pub dynamic_vlan: Option<bool>,
    #[serde(rename = "stormControl", skip_serializing_if = "Option::is_none")]
    pub storm_control: Option<Box<models::PortConfigAllOfStormControl>>,
    #[serde(rename = "portSecurity", skip_serializing_if = "Option::is_none")]
    pub port_security: Option<Box<models::PortConfigAllOfPortSecurity>>,
}

impl PortConfig {
    pub fn new(name: String, r#type: Type, enabled: bool, port_id: i32) -> PortConfig {
        PortConfig {
            name,
            r#type,
            description: None,
            enabled,
            ip_addresses: None,
            mac_address: None,
            mtu: None,
            speed: None,
            duplex: None,
            port_id,
            native_vlan: None,
            acl_in: None,
            max_learned_macs: None,
            dynamic_vlan: None,
            storm_control: None,
            port_security: None,
        }
    }
}
/// Interface type
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Type {
    #[serde(rename = "ethernet")]
    Ethernet,
    #[serde(rename = "wifi")]
    Wifi,
    #[serde(rename = "virtual")]
    Virtual,
    #[serde(rename = "loopback")]
    Loopback,
    #[serde(rename = "tunnel")]
    Tunnel,
}

impl Default for Type {
    fn default() -> Type {
        Self::Ethernet
    }
}
/// Interface duplex mode
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Duplex {
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "half")]
    Half,
    #[serde(rename = "auto")]
    Auto,
}

impl Default for Duplex {
    fn default() -> Duplex {
        Self::Full
    }
}

