/*
H3Net Protocol API

H3Net Protocol schema with various messages and configurations.

API version: 1.0.0
Contact: h3netprotocol@googlegroups.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h3netclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type PipelineAPI interface {

	/*
	CreateFlow Create a new flow entry

	Creates a new flow entry in the specified table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPICreateFlowRequest
	*/
	CreateFlow(ctx context.Context) PipelineAPICreateFlowRequest

	// CreateFlowExecute executes the request
	//  @return FlowEntry
	CreateFlowExecute(r PipelineAPICreateFlowRequest) (*FlowEntry, *http.Response, error)

	/*
	CreateMatchActionTable Create Match-Action Table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPICreateMatchActionTableRequest
	*/
	CreateMatchActionTable(ctx context.Context) PipelineAPICreateMatchActionTableRequest

	// CreateMatchActionTableExecute executes the request
	//  @return MatchActionTable
	CreateMatchActionTableExecute(r PipelineAPICreateMatchActionTableRequest) (*MatchActionTable, *http.Response, error)

	/*
	CreateTable Create a new match-action table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPICreateTableRequest
	*/
	CreateTable(ctx context.Context) PipelineAPICreateTableRequest

	// CreateTableExecute executes the request
	//  @return MatchActionTable
	CreateTableExecute(r PipelineAPICreateTableRequest) (*MatchActionTable, *http.Response, error)

	/*
	GetFlowEntries Get Flow Entries

	Retrieves flow entries from pipeline match-action tables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIGetFlowEntriesRequest
	*/
	GetFlowEntries(ctx context.Context) PipelineAPIGetFlowEntriesRequest

	// GetFlowEntriesExecute executes the request
	//  @return []FlowEntry
	GetFlowEntriesExecute(r PipelineAPIGetFlowEntriesRequest) ([]FlowEntry, *http.Response, error)

	/*
	GetFlows Get all flow entries

	Retrieves all flow entries across all devices and tables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIGetFlowsRequest
	*/
	GetFlows(ctx context.Context) PipelineAPIGetFlowsRequest

	// GetFlowsExecute executes the request
	//  @return []FlowEntry
	GetFlowsExecute(r PipelineAPIGetFlowsRequest) ([]FlowEntry, *http.Response, error)

	/*
	GetMatchActionTables Get Match-Action Tables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIGetMatchActionTablesRequest
	*/
	GetMatchActionTables(ctx context.Context) PipelineAPIGetMatchActionTablesRequest

	// GetMatchActionTablesExecute executes the request
	//  @return []MatchActionTable
	GetMatchActionTablesExecute(r PipelineAPIGetMatchActionTablesRequest) ([]MatchActionTable, *http.Response, error)

	/*
	GetPipelineConfig Get Pipeline Configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIGetPipelineConfigRequest
	*/
	GetPipelineConfig(ctx context.Context) PipelineAPIGetPipelineConfigRequest

	// GetPipelineConfigExecute executes the request
	//  @return PipelineConfig
	GetPipelineConfigExecute(r PipelineAPIGetPipelineConfigRequest) (*PipelineConfig, *http.Response, error)

	/*
	GetPipelineTable Get specific pipeline match-action table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableId ID of the table to retrieve
	@return PipelineAPIGetPipelineTableRequest
	*/
	GetPipelineTable(ctx context.Context, tableId int32) PipelineAPIGetPipelineTableRequest

	// GetPipelineTableExecute executes the request
	//  @return MatchActionTable
	GetPipelineTableExecute(r PipelineAPIGetPipelineTableRequest) (*MatchActionTable, *http.Response, error)

	/*
	GetPipelineTables Get all pipeline match-action tables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIGetPipelineTablesRequest
	*/
	GetPipelineTables(ctx context.Context) PipelineAPIGetPipelineTablesRequest

	// GetPipelineTablesExecute executes the request
	//  @return []MatchActionTable
	GetPipelineTablesExecute(r PipelineAPIGetPipelineTablesRequest) ([]MatchActionTable, *http.Response, error)

	/*
	UpdateFlowEntries Update Flow Entries

	Updates flow entries in the pipeline match-action tables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIUpdateFlowEntriesRequest
	*/
	UpdateFlowEntries(ctx context.Context) PipelineAPIUpdateFlowEntriesRequest

	// UpdateFlowEntriesExecute executes the request
	UpdateFlowEntriesExecute(r PipelineAPIUpdateFlowEntriesRequest) (*http.Response, error)

	/*
	UpdatePipelineConfig Update Pipeline Configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PipelineAPIUpdatePipelineConfigRequest
	*/
	UpdatePipelineConfig(ctx context.Context) PipelineAPIUpdatePipelineConfigRequest

	// UpdatePipelineConfigExecute executes the request
	UpdatePipelineConfigExecute(r PipelineAPIUpdatePipelineConfigRequest) (*http.Response, error)

	/*
	UpdateTable Update a match-action table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableId ID of the table to update
	@return PipelineAPIUpdateTableRequest
	*/
	UpdateTable(ctx context.Context, tableId int32) PipelineAPIUpdateTableRequest

	// UpdateTableExecute executes the request
	//  @return MatchActionTable
	UpdateTableExecute(r PipelineAPIUpdateTableRequest) (*MatchActionTable, *http.Response, error)

	/*
	UpdateTablePipelineConfig Update pipeline configuration for a table

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tableId ID of the table to update pipeline configuration
	@return PipelineAPIUpdateTablePipelineConfigRequest
	*/
	UpdateTablePipelineConfig(ctx context.Context, tableId int32) PipelineAPIUpdateTablePipelineConfigRequest

	// UpdateTablePipelineConfigExecute executes the request
	//  @return PipelineConfig
	UpdateTablePipelineConfigExecute(r PipelineAPIUpdateTablePipelineConfigRequest) (*PipelineConfig, *http.Response, error)
}

// PipelineAPIService PipelineAPI service
type PipelineAPIService service

type PipelineAPICreateFlowRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	idempotencyKey *string
	xClientTimestamp *string
	createFlowRequest *CreateFlowRequest
}

// Unique key for idempotent request handling
func (r PipelineAPICreateFlowRequest) IdempotencyKey(idempotencyKey string) PipelineAPICreateFlowRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Client-side timestamp for request ordering (RFC3339 format)
func (r PipelineAPICreateFlowRequest) XClientTimestamp(xClientTimestamp string) PipelineAPICreateFlowRequest {
	r.xClientTimestamp = &xClientTimestamp
	return r
}

// Flow entry to create
func (r PipelineAPICreateFlowRequest) CreateFlowRequest(createFlowRequest CreateFlowRequest) PipelineAPICreateFlowRequest {
	r.createFlowRequest = &createFlowRequest
	return r
}

func (r PipelineAPICreateFlowRequest) Execute() (*FlowEntry, *http.Response, error) {
	return r.ApiService.CreateFlowExecute(r)
}

/*
CreateFlow Create a new flow entry

Creates a new flow entry in the specified table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPICreateFlowRequest
*/
func (a *PipelineAPIService) CreateFlow(ctx context.Context) PipelineAPICreateFlowRequest {
	return PipelineAPICreateFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowEntry
func (a *PipelineAPIService) CreateFlowExecute(r PipelineAPICreateFlowRequest) (*FlowEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.CreateFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pipeline/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.xClientTimestamp == nil {
		return localVarReturnValue, nil, reportError("xClientTimestamp is required and must be specified")
	}
	if r.createFlowRequest == nil {
		return localVarReturnValue, nil, reportError("createFlowRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Client-Timestamp", r.xClientTimestamp, "simple", "")
	// body params
	localVarPostBody = r.createFlowRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPICreateMatchActionTableRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	idempotencyKey *string
	xClientTimestamp *string
	createMatchActionTableRequest *CreateMatchActionTableRequest
}

// Unique key for idempotent request handling
func (r PipelineAPICreateMatchActionTableRequest) IdempotencyKey(idempotencyKey string) PipelineAPICreateMatchActionTableRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Client-side timestamp for request ordering (RFC3339 format)
func (r PipelineAPICreateMatchActionTableRequest) XClientTimestamp(xClientTimestamp string) PipelineAPICreateMatchActionTableRequest {
	r.xClientTimestamp = &xClientTimestamp
	return r
}

// Match-action table to create
func (r PipelineAPICreateMatchActionTableRequest) CreateMatchActionTableRequest(createMatchActionTableRequest CreateMatchActionTableRequest) PipelineAPICreateMatchActionTableRequest {
	r.createMatchActionTableRequest = &createMatchActionTableRequest
	return r
}

func (r PipelineAPICreateMatchActionTableRequest) Execute() (*MatchActionTable, *http.Response, error) {
	return r.ApiService.CreateMatchActionTableExecute(r)
}

/*
CreateMatchActionTable Create Match-Action Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPICreateMatchActionTableRequest
*/
func (a *PipelineAPIService) CreateMatchActionTable(ctx context.Context) PipelineAPICreateMatchActionTableRequest {
	return PipelineAPICreateMatchActionTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MatchActionTable
func (a *PipelineAPIService) CreateMatchActionTableExecute(r PipelineAPICreateMatchActionTableRequest) (*MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.CreateMatchActionTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline/tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.xClientTimestamp == nil {
		return localVarReturnValue, nil, reportError("xClientTimestamp is required and must be specified")
	}
	if r.createMatchActionTableRequest == nil {
		return localVarReturnValue, nil, reportError("createMatchActionTableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Client-Timestamp", r.xClientTimestamp, "simple", "")
	// body params
	localVarPostBody = r.createMatchActionTableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPICreateTableRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	idempotencyKey *string
	xClientTimestamp *string
	createMatchActionTableRequest *CreateMatchActionTableRequest
}

// Unique key for idempotent request handling
func (r PipelineAPICreateTableRequest) IdempotencyKey(idempotencyKey string) PipelineAPICreateTableRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Client-side timestamp for request ordering (RFC3339 format)
func (r PipelineAPICreateTableRequest) XClientTimestamp(xClientTimestamp string) PipelineAPICreateTableRequest {
	r.xClientTimestamp = &xClientTimestamp
	return r
}

func (r PipelineAPICreateTableRequest) CreateMatchActionTableRequest(createMatchActionTableRequest CreateMatchActionTableRequest) PipelineAPICreateTableRequest {
	r.createMatchActionTableRequest = &createMatchActionTableRequest
	return r
}

func (r PipelineAPICreateTableRequest) Execute() (*MatchActionTable, *http.Response, error) {
	return r.ApiService.CreateTableExecute(r)
}

/*
CreateTable Create a new match-action table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPICreateTableRequest
*/
func (a *PipelineAPIService) CreateTable(ctx context.Context) PipelineAPICreateTableRequest {
	return PipelineAPICreateTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MatchActionTable
func (a *PipelineAPIService) CreateTableExecute(r PipelineAPICreateTableRequest) (*MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.CreateTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.xClientTimestamp == nil {
		return localVarReturnValue, nil, reportError("xClientTimestamp is required and must be specified")
	}
	if r.createMatchActionTableRequest == nil {
		return localVarReturnValue, nil, reportError("createMatchActionTableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Client-Timestamp", r.xClientTimestamp, "simple", "")
	// body params
	localVarPostBody = r.createMatchActionTableRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetFlowEntriesRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	deviceId *string
	tableId *int32
}

// ID of the device
func (r PipelineAPIGetFlowEntriesRequest) DeviceId(deviceId string) PipelineAPIGetFlowEntriesRequest {
	r.deviceId = &deviceId
	return r
}

// ID of the match-action table
func (r PipelineAPIGetFlowEntriesRequest) TableId(tableId int32) PipelineAPIGetFlowEntriesRequest {
	r.tableId = &tableId
	return r
}

func (r PipelineAPIGetFlowEntriesRequest) Execute() ([]FlowEntry, *http.Response, error) {
	return r.ApiService.GetFlowEntriesExecute(r)
}

/*
GetFlowEntries Get Flow Entries

Retrieves flow entries from pipeline match-action tables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIGetFlowEntriesRequest
*/
func (a *PipelineAPIService) GetFlowEntries(ctx context.Context) PipelineAPIGetFlowEntriesRequest {
	return PipelineAPIGetFlowEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FlowEntry
func (a *PipelineAPIService) GetFlowEntriesExecute(r PipelineAPIGetFlowEntriesRequest) ([]FlowEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FlowEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetFlowEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.tableId == nil {
		return localVarReturnValue, nil, reportError("tableId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tableId", r.tableId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetFlowsRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	deviceId *string
	tableId *int32
}

// Optional filter by device ID
func (r PipelineAPIGetFlowsRequest) DeviceId(deviceId string) PipelineAPIGetFlowsRequest {
	r.deviceId = &deviceId
	return r
}

// Optional filter by table ID
func (r PipelineAPIGetFlowsRequest) TableId(tableId int32) PipelineAPIGetFlowsRequest {
	r.tableId = &tableId
	return r
}

func (r PipelineAPIGetFlowsRequest) Execute() ([]FlowEntry, *http.Response, error) {
	return r.ApiService.GetFlowsExecute(r)
}

/*
GetFlows Get all flow entries

Retrieves all flow entries across all devices and tables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIGetFlowsRequest
*/
func (a *PipelineAPIService) GetFlows(ctx context.Context) PipelineAPIGetFlowsRequest {
	return PipelineAPIGetFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FlowEntry
func (a *PipelineAPIService) GetFlowsExecute(r PipelineAPIGetFlowsRequest) ([]FlowEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FlowEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pipeline/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.tableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tableId", r.tableId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetMatchActionTablesRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	deviceId *string
}

// ID of the device
func (r PipelineAPIGetMatchActionTablesRequest) DeviceId(deviceId string) PipelineAPIGetMatchActionTablesRequest {
	r.deviceId = &deviceId
	return r
}

func (r PipelineAPIGetMatchActionTablesRequest) Execute() ([]MatchActionTable, *http.Response, error) {
	return r.ApiService.GetMatchActionTablesExecute(r)
}

/*
GetMatchActionTables Get Match-Action Tables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIGetMatchActionTablesRequest
*/
func (a *PipelineAPIService) GetMatchActionTables(ctx context.Context) PipelineAPIGetMatchActionTablesRequest {
	return PipelineAPIGetMatchActionTablesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MatchActionTable
func (a *PipelineAPIService) GetMatchActionTablesExecute(r PipelineAPIGetMatchActionTablesRequest) ([]MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetMatchActionTables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline/tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetPipelineConfigRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	deviceId *string
}

func (r PipelineAPIGetPipelineConfigRequest) DeviceId(deviceId string) PipelineAPIGetPipelineConfigRequest {
	r.deviceId = &deviceId
	return r
}

func (r PipelineAPIGetPipelineConfigRequest) Execute() (*PipelineConfig, *http.Response, error) {
	return r.ApiService.GetPipelineConfigExecute(r)
}

/*
GetPipelineConfig Get Pipeline Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIGetPipelineConfigRequest
*/
func (a *PipelineAPIService) GetPipelineConfig(ctx context.Context) PipelineAPIGetPipelineConfigRequest {
	return PipelineAPIGetPipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PipelineConfig
func (a *PipelineAPIService) GetPipelineConfigExecute(r PipelineAPIGetPipelineConfigRequest) (*PipelineConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetPipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetPipelineTableRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	tableId int32
}

func (r PipelineAPIGetPipelineTableRequest) Execute() (*MatchActionTable, *http.Response, error) {
	return r.ApiService.GetPipelineTableExecute(r)
}

/*
GetPipelineTable Get specific pipeline match-action table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId ID of the table to retrieve
 @return PipelineAPIGetPipelineTableRequest
*/
func (a *PipelineAPIService) GetPipelineTable(ctx context.Context, tableId int32) PipelineAPIGetPipelineTableRequest {
	return PipelineAPIGetPipelineTableRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return MatchActionTable
func (a *PipelineAPIService) GetPipelineTableExecute(r PipelineAPIGetPipelineTableRequest) (*MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetPipelineTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIGetPipelineTablesRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	deviceId *string
}

// Filter tables by device ID
func (r PipelineAPIGetPipelineTablesRequest) DeviceId(deviceId string) PipelineAPIGetPipelineTablesRequest {
	r.deviceId = &deviceId
	return r
}

func (r PipelineAPIGetPipelineTablesRequest) Execute() ([]MatchActionTable, *http.Response, error) {
	return r.ApiService.GetPipelineTablesExecute(r)
}

/*
GetPipelineTables Get all pipeline match-action tables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIGetPipelineTablesRequest
*/
func (a *PipelineAPIService) GetPipelineTables(ctx context.Context) PipelineAPIGetPipelineTablesRequest {
	return PipelineAPIGetPipelineTablesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MatchActionTable
func (a *PipelineAPIService) GetPipelineTablesExecute(r PipelineAPIGetPipelineTablesRequest) ([]MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.GetPipelineTables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIUpdateFlowEntriesRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	flowEntry *FlowEntry
}

// Flow entries to update
func (r PipelineAPIUpdateFlowEntriesRequest) FlowEntry(flowEntry FlowEntry) PipelineAPIUpdateFlowEntriesRequest {
	r.flowEntry = &flowEntry
	return r
}

func (r PipelineAPIUpdateFlowEntriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateFlowEntriesExecute(r)
}

/*
UpdateFlowEntries Update Flow Entries

Updates flow entries in the pipeline match-action tables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIUpdateFlowEntriesRequest
*/
func (a *PipelineAPIService) UpdateFlowEntries(ctx context.Context) PipelineAPIUpdateFlowEntriesRequest {
	return PipelineAPIUpdateFlowEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PipelineAPIService) UpdateFlowEntriesExecute(r PipelineAPIUpdateFlowEntriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.UpdateFlowEntries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.flowEntry == nil {
		return nil, reportError("flowEntry is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flowEntry
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelineAPIUpdatePipelineConfigRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	idempotencyKey *string
	xClientTimestamp *string
	updatePipelineConfigRequest *UpdatePipelineConfigRequest
}

// Unique key for idempotent request handling
func (r PipelineAPIUpdatePipelineConfigRequest) IdempotencyKey(idempotencyKey string) PipelineAPIUpdatePipelineConfigRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Client-side timestamp for request ordering (RFC3339 format)
func (r PipelineAPIUpdatePipelineConfigRequest) XClientTimestamp(xClientTimestamp string) PipelineAPIUpdatePipelineConfigRequest {
	r.xClientTimestamp = &xClientTimestamp
	return r
}

// Pipeline configuration to update
func (r PipelineAPIUpdatePipelineConfigRequest) UpdatePipelineConfigRequest(updatePipelineConfigRequest UpdatePipelineConfigRequest) PipelineAPIUpdatePipelineConfigRequest {
	r.updatePipelineConfigRequest = &updatePipelineConfigRequest
	return r
}

func (r PipelineAPIUpdatePipelineConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePipelineConfigExecute(r)
}

/*
UpdatePipelineConfig Update Pipeline Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PipelineAPIUpdatePipelineConfigRequest
*/
func (a *PipelineAPIService) UpdatePipelineConfig(ctx context.Context) PipelineAPIUpdatePipelineConfigRequest {
	return PipelineAPIUpdatePipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PipelineAPIService) UpdatePipelineConfigExecute(r PipelineAPIUpdatePipelineConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.UpdatePipelineConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/pipeline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.xClientTimestamp == nil {
		return nil, reportError("xClientTimestamp is required and must be specified")
	}
	if r.updatePipelineConfigRequest == nil {
		return nil, reportError("updatePipelineConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Client-Timestamp", r.xClientTimestamp, "simple", "")
	// body params
	localVarPostBody = r.updatePipelineConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelineAPIUpdateTableRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	tableId int32
	matchActionTable *MatchActionTable
}

func (r PipelineAPIUpdateTableRequest) MatchActionTable(matchActionTable MatchActionTable) PipelineAPIUpdateTableRequest {
	r.matchActionTable = &matchActionTable
	return r
}

func (r PipelineAPIUpdateTableRequest) Execute() (*MatchActionTable, *http.Response, error) {
	return r.ApiService.UpdateTableExecute(r)
}

/*
UpdateTable Update a match-action table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId ID of the table to update
 @return PipelineAPIUpdateTableRequest
*/
func (a *PipelineAPIService) UpdateTable(ctx context.Context, tableId int32) PipelineAPIUpdateTableRequest {
	return PipelineAPIUpdateTableRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return MatchActionTable
func (a *PipelineAPIService) UpdateTableExecute(r PipelineAPIUpdateTableRequest) (*MatchActionTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchActionTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.UpdateTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchActionTable == nil {
		return localVarReturnValue, nil, reportError("matchActionTable is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.matchActionTable
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelineAPIUpdateTablePipelineConfigRequest struct {
	ctx context.Context
	ApiService PipelineAPI
	tableId int32
	pipelineUpdateMessage *PipelineUpdateMessage
}

func (r PipelineAPIUpdateTablePipelineConfigRequest) PipelineUpdateMessage(pipelineUpdateMessage PipelineUpdateMessage) PipelineAPIUpdateTablePipelineConfigRequest {
	r.pipelineUpdateMessage = &pipelineUpdateMessage
	return r
}

func (r PipelineAPIUpdateTablePipelineConfigRequest) Execute() (*PipelineConfig, *http.Response, error) {
	return r.ApiService.UpdateTablePipelineConfigExecute(r)
}

/*
UpdateTablePipelineConfig Update pipeline configuration for a table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId ID of the table to update pipeline configuration
 @return PipelineAPIUpdateTablePipelineConfigRequest
*/
func (a *PipelineAPIService) UpdateTablePipelineConfig(ctx context.Context, tableId int32) PipelineAPIUpdateTablePipelineConfigRequest {
	return PipelineAPIUpdateTablePipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return PipelineConfig
func (a *PipelineAPIService) UpdateTablePipelineConfigExecute(r PipelineAPIUpdateTablePipelineConfigRequest) (*PipelineConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelineAPIService.UpdateTablePipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableId}/pipeline"
	localVarPath = strings.Replace(localVarPath, "{"+"tableId"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pipelineUpdateMessage == nil {
		return localVarReturnValue, nil, reportError("pipelineUpdateMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pipelineUpdateMessage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["coreAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
