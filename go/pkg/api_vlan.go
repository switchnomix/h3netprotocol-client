/*
H3Net Protocol API

H3Net Protocol schema with various messages and configurations.

API version: 1.0.0
Contact: h3netprotocol@googlegroups.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h3netclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type VlanAPI interface {

	/*
	CreateVLAN Create new VLAN

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return VlanAPICreateVLANRequest
	*/
	CreateVLAN(ctx context.Context, deviceId string) VlanAPICreateVLANRequest

	// CreateVLANExecute executes the request
	//  @return VLAN
	CreateVLANExecute(r VlanAPICreateVLANRequest) (*VLAN, *http.Response, error)

	/*
	DeleteVLAN Delete VLAN

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param vlanId
	@return VlanAPIDeleteVLANRequest
	*/
	DeleteVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIDeleteVLANRequest

	// DeleteVLANExecute executes the request
	DeleteVLANExecute(r VlanAPIDeleteVLANRequest) (*http.Response, error)

	/*
	GetAllVlanConfigs Get all VLAN configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return VlanAPIGetAllVlanConfigsRequest
	*/
	GetAllVlanConfigs(ctx context.Context) VlanAPIGetAllVlanConfigsRequest

	// GetAllVlanConfigsExecute executes the request
	//  @return []VLAN
	GetAllVlanConfigsExecute(r VlanAPIGetAllVlanConfigsRequest) ([]VLAN, *http.Response, error)

	/*
	GetDeviceVLANs Get all VLANs for a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return VlanAPIGetDeviceVLANsRequest
	*/
	GetDeviceVLANs(ctx context.Context, deviceId string) VlanAPIGetDeviceVLANsRequest

	// GetDeviceVLANsExecute executes the request
	//  @return []VLAN
	GetDeviceVLANsExecute(r VlanAPIGetDeviceVLANsRequest) ([]VLAN, *http.Response, error)

	/*
	GetVLAN Get VLAN details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param vlanId
	@return VlanAPIGetVLANRequest
	*/
	GetVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIGetVLANRequest

	// GetVLANExecute executes the request
	//  @return VLAN
	GetVLANExecute(r VlanAPIGetVLANRequest) (*VLAN, *http.Response, error)

	/*
	GetVlanConfigById Get specific VLAN configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param vlanId
	@return VlanAPIGetVlanConfigByIdRequest
	*/
	GetVlanConfigById(ctx context.Context, vlanId string) VlanAPIGetVlanConfigByIdRequest

	// GetVlanConfigByIdExecute executes the request
	//  @return VLAN
	GetVlanConfigByIdExecute(r VlanAPIGetVlanConfigByIdRequest) (*VLAN, *http.Response, error)

	/*
	UpdateVLAN Update VLAN configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param vlanId
	@return VlanAPIUpdateVLANRequest
	*/
	UpdateVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANRequest

	// UpdateVLANExecute executes the request
	UpdateVLANExecute(r VlanAPIUpdateVLANRequest) (*http.Response, error)

	/*
	UpdateVLANPorts Update VLAN port assignments

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param vlanId
	@return VlanAPIUpdateVLANPortsRequest
	*/
	UpdateVLANPorts(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANPortsRequest

	// UpdateVLANPortsExecute executes the request
	UpdateVLANPortsExecute(r VlanAPIUpdateVLANPortsRequest) (*http.Response, error)

	/*
	UpdateVLANProperties Update VLAN properties

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param vlanId
	@return VlanAPIUpdateVLANPropertiesRequest
	*/
	UpdateVLANProperties(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANPropertiesRequest

	// UpdateVLANPropertiesExecute executes the request
	UpdateVLANPropertiesExecute(r VlanAPIUpdateVLANPropertiesRequest) (*http.Response, error)

	/*
	UpdateVlanConfigById Update VLAN configuration by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param vlanId
	@return VlanAPIUpdateVlanConfigByIdRequest
	*/
	UpdateVlanConfigById(ctx context.Context, vlanId string) VlanAPIUpdateVlanConfigByIdRequest

	// UpdateVlanConfigByIdExecute executes the request
	UpdateVlanConfigByIdExecute(r VlanAPIUpdateVlanConfigByIdRequest) (*http.Response, error)
}

// VlanAPIService VlanAPI service
type VlanAPIService service

type VlanAPICreateVLANRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vLAN *VLAN
}

func (r VlanAPICreateVLANRequest) VLAN(vLAN VLAN) VlanAPICreateVLANRequest {
	r.vLAN = &vLAN
	return r
}

func (r VlanAPICreateVLANRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.CreateVLANExecute(r)
}

/*
CreateVLAN Create new VLAN

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return VlanAPICreateVLANRequest
*/
func (a *VlanAPIService) CreateVLAN(ctx context.Context, deviceId string) VlanAPICreateVLANRequest {
	return VlanAPICreateVLANRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return VLAN
func (a *VlanAPIService) CreateVLANExecute(r VlanAPICreateVLANRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.CreateVLAN")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLAN == nil {
		return localVarReturnValue, nil, reportError("vLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLAN
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VlanAPIDeleteVLANRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vlanId int32
}

func (r VlanAPIDeleteVLANRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVLANExecute(r)
}

/*
DeleteVLAN Delete VLAN

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param vlanId
 @return VlanAPIDeleteVLANRequest
*/
func (a *VlanAPIService) DeleteVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIDeleteVLANRequest {
	return VlanAPIDeleteVLANRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		vlanId: vlanId,
	}
}

// Execute executes the request
func (a *VlanAPIService) DeleteVLANExecute(r VlanAPIDeleteVLANRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.DeleteVLAN")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}/{vlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId < 1 {
		return nil, reportError("vlanId must be greater than 1")
	}
	if r.vlanId > 4094 {
		return nil, reportError("vlanId must be less than 4094")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VlanAPIGetAllVlanConfigsRequest struct {
	ctx context.Context
	ApiService VlanAPI
}

func (r VlanAPIGetAllVlanConfigsRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.GetAllVlanConfigsExecute(r)
}

/*
GetAllVlanConfigs Get all VLAN configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VlanAPIGetAllVlanConfigsRequest
*/
func (a *VlanAPIService) GetAllVlanConfigs(ctx context.Context) VlanAPIGetAllVlanConfigsRequest {
	return VlanAPIGetAllVlanConfigsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *VlanAPIService) GetAllVlanConfigsExecute(r VlanAPIGetAllVlanConfigsRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.GetAllVlanConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VlanAPIGetDeviceVLANsRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
}

func (r VlanAPIGetDeviceVLANsRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.GetDeviceVLANsExecute(r)
}

/*
GetDeviceVLANs Get all VLANs for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return VlanAPIGetDeviceVLANsRequest
*/
func (a *VlanAPIService) GetDeviceVLANs(ctx context.Context, deviceId string) VlanAPIGetDeviceVLANsRequest {
	return VlanAPIGetDeviceVLANsRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *VlanAPIService) GetDeviceVLANsExecute(r VlanAPIGetDeviceVLANsRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.GetDeviceVLANs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VlanAPIGetVLANRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vlanId int32
}

func (r VlanAPIGetVLANRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.GetVLANExecute(r)
}

/*
GetVLAN Get VLAN details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param vlanId
 @return VlanAPIGetVLANRequest
*/
func (a *VlanAPIService) GetVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIGetVLANRequest {
	return VlanAPIGetVLANRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		vlanId: vlanId,
	}
}

// Execute executes the request
//  @return VLAN
func (a *VlanAPIService) GetVLANExecute(r VlanAPIGetVLANRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.GetVLAN")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}/{vlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId < 1 {
		return localVarReturnValue, nil, reportError("vlanId must be greater than 1")
	}
	if r.vlanId > 4094 {
		return localVarReturnValue, nil, reportError("vlanId must be less than 4094")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VlanAPIGetVlanConfigByIdRequest struct {
	ctx context.Context
	ApiService VlanAPI
	vlanId string
}

func (r VlanAPIGetVlanConfigByIdRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.GetVlanConfigByIdExecute(r)
}

/*
GetVlanConfigById Get specific VLAN configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vlanId
 @return VlanAPIGetVlanConfigByIdRequest
*/
func (a *VlanAPIService) GetVlanConfigById(ctx context.Context, vlanId string) VlanAPIGetVlanConfigByIdRequest {
	return VlanAPIGetVlanConfigByIdRequest{
		ApiService: a,
		ctx: ctx,
		vlanId: vlanId,
	}
}

// Execute executes the request
//  @return VLAN
func (a *VlanAPIService) GetVlanConfigByIdExecute(r VlanAPIGetVlanConfigByIdRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.GetVlanConfigById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/id/{vlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VlanAPIUpdateVLANRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vlanId int32
	vLAN *VLAN
}

func (r VlanAPIUpdateVLANRequest) VLAN(vLAN VLAN) VlanAPIUpdateVLANRequest {
	r.vLAN = &vLAN
	return r
}

func (r VlanAPIUpdateVLANRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVLANExecute(r)
}

/*
UpdateVLAN Update VLAN configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param vlanId
 @return VlanAPIUpdateVLANRequest
*/
func (a *VlanAPIService) UpdateVLAN(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANRequest {
	return VlanAPIUpdateVLANRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		vlanId: vlanId,
	}
}

// Execute executes the request
func (a *VlanAPIService) UpdateVLANExecute(r VlanAPIUpdateVLANRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.UpdateVLAN")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}/{vlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId < 1 {
		return nil, reportError("vlanId must be greater than 1")
	}
	if r.vlanId > 4094 {
		return nil, reportError("vlanId must be less than 4094")
	}
	if r.vLAN == nil {
		return nil, reportError("vLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLAN
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VlanAPIUpdateVLANPortsRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vlanId int32
	ports *Ports
}

func (r VlanAPIUpdateVLANPortsRequest) Ports(ports Ports) VlanAPIUpdateVLANPortsRequest {
	r.ports = &ports
	return r
}

func (r VlanAPIUpdateVLANPortsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVLANPortsExecute(r)
}

/*
UpdateVLANPorts Update VLAN port assignments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param vlanId
 @return VlanAPIUpdateVLANPortsRequest
*/
func (a *VlanAPIService) UpdateVLANPorts(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANPortsRequest {
	return VlanAPIUpdateVLANPortsRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		vlanId: vlanId,
	}
}

// Execute executes the request
func (a *VlanAPIService) UpdateVLANPortsExecute(r VlanAPIUpdateVLANPortsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.UpdateVLANPorts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}/{vlanId}/ports"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId < 1 {
		return nil, reportError("vlanId must be greater than 1")
	}
	if r.vlanId > 4094 {
		return nil, reportError("vlanId must be less than 4094")
	}
	if r.ports == nil {
		return nil, reportError("ports is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ports
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VlanAPIUpdateVLANPropertiesRequest struct {
	ctx context.Context
	ApiService VlanAPI
	deviceId string
	vlanId int32
	vLANProperties *VLANProperties
}

func (r VlanAPIUpdateVLANPropertiesRequest) VLANProperties(vLANProperties VLANProperties) VlanAPIUpdateVLANPropertiesRequest {
	r.vLANProperties = &vLANProperties
	return r
}

func (r VlanAPIUpdateVLANPropertiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVLANPropertiesExecute(r)
}

/*
UpdateVLANProperties Update VLAN properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param vlanId
 @return VlanAPIUpdateVLANPropertiesRequest
*/
func (a *VlanAPIService) UpdateVLANProperties(ctx context.Context, deviceId string, vlanId int32) VlanAPIUpdateVLANPropertiesRequest {
	return VlanAPIUpdateVLANPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		vlanId: vlanId,
	}
}

// Execute executes the request
func (a *VlanAPIService) UpdateVLANPropertiesExecute(r VlanAPIUpdateVLANPropertiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.UpdateVLANProperties")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/{deviceId}/{vlanId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId < 1 {
		return nil, reportError("vlanId must be greater than 1")
	}
	if r.vlanId > 4094 {
		return nil, reportError("vlanId must be less than 4094")
	}
	if r.vLANProperties == nil {
		return nil, reportError("vLANProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANProperties
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VlanAPIUpdateVlanConfigByIdRequest struct {
	ctx context.Context
	ApiService VlanAPI
	vlanId string
	vLAN *VLAN
}

func (r VlanAPIUpdateVlanConfigByIdRequest) VLAN(vLAN VLAN) VlanAPIUpdateVlanConfigByIdRequest {
	r.vLAN = &vLAN
	return r
}

func (r VlanAPIUpdateVlanConfigByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVlanConfigByIdExecute(r)
}

/*
UpdateVlanConfigById Update VLAN configuration by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vlanId
 @return VlanAPIUpdateVlanConfigByIdRequest
*/
func (a *VlanAPIService) UpdateVlanConfigById(ctx context.Context, vlanId string) VlanAPIUpdateVlanConfigByIdRequest {
	return VlanAPIUpdateVlanConfigByIdRequest{
		ApiService: a,
		ctx: ctx,
		vlanId: vlanId,
	}
}

// Execute executes the request
func (a *VlanAPIService) UpdateVlanConfigByIdExecute(r VlanAPIUpdateVlanConfigByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VlanAPIService.UpdateVlanConfigById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlans/id/{vlanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"vlanId"+"}", url.PathEscape(parameterValueToString(r.vlanId, "vlanId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLAN == nil {
		return nil, reportError("vLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLAN
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
