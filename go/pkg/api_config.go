/*
H3Net Protocol API

H3Net Protocol schema with various messages and configurations.

API version: 1.0.0
Contact: h3netprotocol@googlegroups.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h3netclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type ConfigAPI interface {

	/*
	AddACLRule Add rule to ACL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@return ConfigAPIAddACLRuleRequest
	*/
	AddACLRule(ctx context.Context, deviceId string, aclName string) ConfigAPIAddACLRuleRequest

	// AddACLRuleExecute executes the request
	//  @return ACLRule
	AddACLRuleExecute(r ConfigAPIAddACLRuleRequest) (*ACLRule, *http.Response, error)

	/*
	CreateOrUpdateDevice Create or update device configuration

	Create a new device or update an existing device configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPICreateOrUpdateDeviceRequest
	*/
	CreateOrUpdateDevice(ctx context.Context) ConfigAPICreateOrUpdateDeviceRequest

	// CreateOrUpdateDeviceExecute executes the request
	CreateOrUpdateDeviceExecute(r ConfigAPICreateOrUpdateDeviceRequest) (*http.Response, error)

	/*
	CreateVlanConfig Create or Update VLAN Configuration

	Create a new VLAN or update existing VLAN configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPICreateVlanConfigRequest
	*/
	CreateVlanConfig(ctx context.Context) ConfigAPICreateVlanConfigRequest

	// CreateVlanConfigExecute executes the request
	CreateVlanConfigExecute(r ConfigAPICreateVlanConfigRequest) (*http.Response, error)

	/*
	DeleteACL Delete ACL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@return ConfigAPIDeleteACLRequest
	*/
	DeleteACL(ctx context.Context, deviceId string, aclName string) ConfigAPIDeleteACLRequest

	// DeleteACLExecute executes the request
	DeleteACLExecute(r ConfigAPIDeleteACLRequest) (*http.Response, error)

	/*
	DeleteACLRule Delete ACL rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@param ruleId
	@return ConfigAPIDeleteACLRuleRequest
	*/
	DeleteACLRule(ctx context.Context, deviceId string, aclName string, ruleId int32) ConfigAPIDeleteACLRuleRequest

	// DeleteACLRuleExecute executes the request
	DeleteACLRuleExecute(r ConfigAPIDeleteACLRuleRequest) (*http.Response, error)

	/*
	GetACL Get specific ACL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@return ConfigAPIGetACLRequest
	*/
	GetACL(ctx context.Context, deviceId string, aclName string) ConfigAPIGetACLRequest

	// GetACLExecute executes the request
	//  @return ACL
	GetACLExecute(r ConfigAPIGetACLRequest) (*ACL, *http.Response, error)

	/*
	GetAllDeviceConfigs Get all device configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIGetAllDeviceConfigsRequest
	*/
	GetAllDeviceConfigs(ctx context.Context) ConfigAPIGetAllDeviceConfigsRequest

	// GetAllDeviceConfigsExecute executes the request
	//  @return []Device
	GetAllDeviceConfigsExecute(r ConfigAPIGetAllDeviceConfigsRequest) ([]Device, *http.Response, error)

	/*
	GetDeviceConfig Get device configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIGetDeviceConfigRequest
	*/
	GetDeviceConfig(ctx context.Context, deviceId string) ConfigAPIGetDeviceConfigRequest

	// GetDeviceConfigExecute executes the request
	//  @return DeviceSettings
	GetDeviceConfigExecute(r ConfigAPIGetDeviceConfigRequest) (*DeviceSettings, *http.Response, error)

	/*
	GetDeviceInfo Get device information

	Query device information using DeviceInfoRequest parameters. The type parameter must be DEVICE_INFO_REQUEST to match the DeviceInfoRequest component schema.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId ID of the device to query (from DeviceInfoRequest)
	@return ConfigAPIGetDeviceInfoRequest
	*/
	GetDeviceInfo(ctx context.Context, deviceId string) ConfigAPIGetDeviceInfoRequest

	// GetDeviceInfoExecute executes the request
	//  @return DeviceInfoResponse
	GetDeviceInfoExecute(r ConfigAPIGetDeviceInfoRequest) (*DeviceInfoResponse, *http.Response, error)

	/*
	GetDeviceInterfaces Get device interfaces configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIGetDeviceInterfacesRequest
	*/
	GetDeviceInterfaces(ctx context.Context, deviceId string) ConfigAPIGetDeviceInterfacesRequest

	// GetDeviceInterfacesExecute executes the request
	//  @return map[string]GetDeviceInterfaces200ResponseValue
	GetDeviceInterfacesExecute(r ConfigAPIGetDeviceInterfacesRequest) (*map[string]GetDeviceInterfaces200ResponseValue, *http.Response, error)

	/*
	GetRoutingConfig Get Routing Configuration

	Retrieve device routing configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIGetRoutingConfigRequest
	*/
	GetRoutingConfig(ctx context.Context) ConfigAPIGetRoutingConfigRequest

	// GetRoutingConfigExecute executes the request
	//  @return RoutingConfig
	GetRoutingConfigExecute(r ConfigAPIGetRoutingConfigRequest) (*RoutingConfig, *http.Response, error)

	/*
	GetSwitchConfig Get Switch Configuration

	Retrieves the configuration of a network switch including features, ports, and capabilities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIGetSwitchConfigRequest
	*/
	GetSwitchConfig(ctx context.Context) ConfigAPIGetSwitchConfigRequest

	// GetSwitchConfigExecute executes the request
	//  @return SwitchDeviceConfig
	GetSwitchConfigExecute(r ConfigAPIGetSwitchConfigRequest) (*SwitchDeviceConfig, *http.Response, error)

	/*
	GetSystemSettings Get system settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIGetSystemSettingsRequest
	*/
	GetSystemSettings(ctx context.Context, deviceId string) ConfigAPIGetSystemSettingsRequest

	// GetSystemSettingsExecute executes the request
	//  @return GetSystemSettings200Response
	GetSystemSettingsExecute(r ConfigAPIGetSystemSettingsRequest) (*GetSystemSettings200Response, *http.Response, error)

	/*
	GetVlanConfig Get VLAN Configuration

	Retrieve VLAN configuration details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIGetVlanConfigRequest
	*/
	GetVlanConfig(ctx context.Context) ConfigAPIGetVlanConfigRequest

	// GetVlanConfigExecute executes the request
	//  @return VLAN
	GetVlanConfigExecute(r ConfigAPIGetVlanConfigRequest) (*VLAN, *http.Response, error)

	/*
	PutRoutingConfig Update Routing Configuration

	Update device routing configuration including static routes and routing protocols

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIPutRoutingConfigRequest
	*/
	PutRoutingConfig(ctx context.Context) ConfigAPIPutRoutingConfigRequest

	// PutRoutingConfigExecute executes the request
	PutRoutingConfigExecute(r ConfigAPIPutRoutingConfigRequest) (*http.Response, error)

	/*
	RequestBulkDeviceInfo Request information for multiple devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIRequestBulkDeviceInfoRequest
	*/
	RequestBulkDeviceInfo(ctx context.Context) ConfigAPIRequestBulkDeviceInfoRequest

	// RequestBulkDeviceInfoExecute executes the request
	//  @return map[string]DeviceInfoResponse
	RequestBulkDeviceInfoExecute(r ConfigAPIRequestBulkDeviceInfoRequest) (*map[string]DeviceInfoResponse, *http.Response, error)

	/*
	RequestDeviceInfo Request device information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIRequestDeviceInfoRequest
	*/
	RequestDeviceInfo(ctx context.Context, deviceId string) ConfigAPIRequestDeviceInfoRequest

	// RequestDeviceInfoExecute executes the request
	//  @return DeviceInfoResponse
	RequestDeviceInfoExecute(r ConfigAPIRequestDeviceInfoRequest) (*DeviceInfoResponse, *http.Response, error)

	/*
	UpdateACL Create or update ACL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@return ConfigAPIUpdateACLRequest
	*/
	UpdateACL(ctx context.Context, deviceId string, aclName string) ConfigAPIUpdateACLRequest

	// UpdateACLExecute executes the request
	//  @return ACL
	UpdateACLExecute(r ConfigAPIUpdateACLRequest) (*ACL, *http.Response, error)

	/*
	UpdateACLRule Update ACL rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param aclName
	@param ruleId
	@return ConfigAPIUpdateACLRuleRequest
	*/
	UpdateACLRule(ctx context.Context, deviceId string, aclName string, ruleId int32) ConfigAPIUpdateACLRuleRequest

	// UpdateACLRuleExecute executes the request
	//  @return ACLRule
	UpdateACLRuleExecute(r ConfigAPIUpdateACLRuleRequest) (*ACLRule, *http.Response, error)

	/*
	UpdateDeviceConfig Update device configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIUpdateDeviceConfigRequest
	*/
	UpdateDeviceConfig(ctx context.Context, deviceId string) ConfigAPIUpdateDeviceConfigRequest

	// UpdateDeviceConfigExecute executes the request
	//  @return DeviceSettings
	UpdateDeviceConfigExecute(r ConfigAPIUpdateDeviceConfigRequest) (*DeviceSettings, *http.Response, error)

	/*
	UpdateInterfaceConfig Update interface configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@param interfaceId
	@return ConfigAPIUpdateInterfaceConfigRequest
	*/
	UpdateInterfaceConfig(ctx context.Context, deviceId string, interfaceId string) ConfigAPIUpdateInterfaceConfigRequest

	// UpdateInterfaceConfigExecute executes the request
	UpdateInterfaceConfigExecute(r ConfigAPIUpdateInterfaceConfigRequest) (*http.Response, error)

	/*
	UpdateSwitchConfig Update Switch Configuration

	Updates the configuration of a network switch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIUpdateSwitchConfigRequest
	*/
	UpdateSwitchConfig(ctx context.Context) ConfigAPIUpdateSwitchConfigRequest

	// UpdateSwitchConfigExecute executes the request
	UpdateSwitchConfigExecute(r ConfigAPIUpdateSwitchConfigRequest) (*http.Response, error)

	/*
	UpdateSystemSettings Update system settings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deviceId
	@return ConfigAPIUpdateSystemSettingsRequest
	*/
	UpdateSystemSettings(ctx context.Context, deviceId string) ConfigAPIUpdateSystemSettingsRequest

	// UpdateSystemSettingsExecute executes the request
	UpdateSystemSettingsExecute(r ConfigAPIUpdateSystemSettingsRequest) (*http.Response, error)

	/*
	UpdateVlanConfig Update VLAN Configuration

	Update existing VLAN configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConfigAPIUpdateVlanConfigRequest
	*/
	UpdateVlanConfig(ctx context.Context) ConfigAPIUpdateVlanConfigRequest

	// UpdateVlanConfigExecute executes the request
	UpdateVlanConfigExecute(r ConfigAPIUpdateVlanConfigRequest) (*http.Response, error)
}

// ConfigAPIService ConfigAPI service
type ConfigAPIService service

type ConfigAPIAddACLRuleRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
	aCLRule *ACLRule
}

func (r ConfigAPIAddACLRuleRequest) ACLRule(aCLRule ACLRule) ConfigAPIAddACLRuleRequest {
	r.aCLRule = &aCLRule
	return r
}

func (r ConfigAPIAddACLRuleRequest) Execute() (*ACLRule, *http.Response, error) {
	return r.ApiService.AddACLRuleExecute(r)
}

/*
AddACLRule Add rule to ACL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @return ConfigAPIAddACLRuleRequest
*/
func (a *ConfigAPIService) AddACLRule(ctx context.Context, deviceId string, aclName string) ConfigAPIAddACLRuleRequest {
	return ConfigAPIAddACLRuleRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
	}
}

// Execute executes the request
//  @return ACLRule
func (a *ConfigAPIService) AddACLRuleExecute(r ConfigAPIAddACLRuleRequest) (*ACLRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ACLRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.AddACLRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aCLRule == nil {
		return localVarReturnValue, nil, reportError("aCLRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aCLRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPICreateOrUpdateDeviceRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	idempotencyKey *string
	xClientTimestamp *string
	createOrUpdateDeviceRequest *CreateOrUpdateDeviceRequest
}

// Unique key for idempotent request handling
func (r ConfigAPICreateOrUpdateDeviceRequest) IdempotencyKey(idempotencyKey string) ConfigAPICreateOrUpdateDeviceRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Client-side timestamp for request ordering (RFC3339 format)
func (r ConfigAPICreateOrUpdateDeviceRequest) XClientTimestamp(xClientTimestamp string) ConfigAPICreateOrUpdateDeviceRequest {
	r.xClientTimestamp = &xClientTimestamp
	return r
}

func (r ConfigAPICreateOrUpdateDeviceRequest) CreateOrUpdateDeviceRequest(createOrUpdateDeviceRequest CreateOrUpdateDeviceRequest) ConfigAPICreateOrUpdateDeviceRequest {
	r.createOrUpdateDeviceRequest = &createOrUpdateDeviceRequest
	return r
}

func (r ConfigAPICreateOrUpdateDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateOrUpdateDeviceExecute(r)
}

/*
CreateOrUpdateDevice Create or update device configuration

Create a new device or update an existing device configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPICreateOrUpdateDeviceRequest
*/
func (a *ConfigAPIService) CreateOrUpdateDevice(ctx context.Context) ConfigAPICreateOrUpdateDeviceRequest {
	return ConfigAPICreateOrUpdateDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigAPIService) CreateOrUpdateDeviceExecute(r ConfigAPICreateOrUpdateDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.CreateOrUpdateDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.xClientTimestamp == nil {
		return nil, reportError("xClientTimestamp is required and must be specified")
	}
	if r.createOrUpdateDeviceRequest == nil {
		return nil, reportError("createOrUpdateDeviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Client-Timestamp", r.xClientTimestamp, "simple", "")
	// body params
	localVarPostBody = r.createOrUpdateDeviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPICreateVlanConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	vLAN *VLAN
}

// VLAN configuration details
func (r ConfigAPICreateVlanConfigRequest) VLAN(vLAN VLAN) ConfigAPICreateVlanConfigRequest {
	r.vLAN = &vLAN
	return r
}

func (r ConfigAPICreateVlanConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateVlanConfigExecute(r)
}

/*
CreateVlanConfig Create or Update VLAN Configuration

Create a new VLAN or update existing VLAN configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPICreateVlanConfigRequest
*/
func (a *ConfigAPIService) CreateVlanConfig(ctx context.Context) ConfigAPICreateVlanConfigRequest {
	return ConfigAPICreateVlanConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigAPIService) CreateVlanConfigExecute(r ConfigAPICreateVlanConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.CreateVlanConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLAN == nil {
		return nil, reportError("vLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIDeleteACLRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
}

func (r ConfigAPIDeleteACLRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteACLExecute(r)
}

/*
DeleteACL Delete ACL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @return ConfigAPIDeleteACLRequest
*/
func (a *ConfigAPIService) DeleteACL(ctx context.Context, deviceId string, aclName string) ConfigAPIDeleteACLRequest {
	return ConfigAPIDeleteACLRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
	}
}

// Execute executes the request
func (a *ConfigAPIService) DeleteACLExecute(r ConfigAPIDeleteACLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.DeleteACL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIDeleteACLRuleRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
	ruleId int32
}

func (r ConfigAPIDeleteACLRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteACLRuleExecute(r)
}

/*
DeleteACLRule Delete ACL rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @param ruleId
 @return ConfigAPIDeleteACLRuleRequest
*/
func (a *ConfigAPIService) DeleteACLRule(ctx context.Context, deviceId string, aclName string, ruleId int32) ConfigAPIDeleteACLRuleRequest {
	return ConfigAPIDeleteACLRuleRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
		ruleId: ruleId,
	}
}

// Execute executes the request
func (a *ConfigAPIService) DeleteACLRuleExecute(r ConfigAPIDeleteACLRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.DeleteACLRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIGetACLRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
}

func (r ConfigAPIGetACLRequest) Execute() (*ACL, *http.Response, error) {
	return r.ApiService.GetACLExecute(r)
}

/*
GetACL Get specific ACL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @return ConfigAPIGetACLRequest
*/
func (a *ConfigAPIService) GetACL(ctx context.Context, deviceId string, aclName string) ConfigAPIGetACLRequest {
	return ConfigAPIGetACLRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
	}
}

// Execute executes the request
//  @return ACL
func (a *ConfigAPIService) GetACLExecute(r ConfigAPIGetACLRequest) (*ACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetAllDeviceConfigsRequest struct {
	ctx context.Context
	ApiService ConfigAPI
}

func (r ConfigAPIGetAllDeviceConfigsRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.GetAllDeviceConfigsExecute(r)
}

/*
GetAllDeviceConfigs Get all device configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIGetAllDeviceConfigsRequest
*/
func (a *ConfigAPIService) GetAllDeviceConfigs(ctx context.Context) ConfigAPIGetAllDeviceConfigsRequest {
	return ConfigAPIGetAllDeviceConfigsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *ConfigAPIService) GetAllDeviceConfigsExecute(r ConfigAPIGetAllDeviceConfigsRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetAllDeviceConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetDeviceConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
}

func (r ConfigAPIGetDeviceConfigRequest) Execute() (*DeviceSettings, *http.Response, error) {
	return r.ApiService.GetDeviceConfigExecute(r)
}

/*
GetDeviceConfig Get device configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIGetDeviceConfigRequest
*/
func (a *ConfigAPIService) GetDeviceConfig(ctx context.Context, deviceId string) ConfigAPIGetDeviceConfigRequest {
	return ConfigAPIGetDeviceConfigRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return DeviceSettings
func (a *ConfigAPIService) GetDeviceConfigExecute(r ConfigAPIGetDeviceConfigRequest) (*DeviceSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetDeviceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetDeviceInfoRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	type_ *string
	timestamp *time.Time
}

// Message type, must be DEVICE_INFO_REQUEST (from DeviceInfoRequest)
func (r ConfigAPIGetDeviceInfoRequest) Type_(type_ string) ConfigAPIGetDeviceInfoRequest {
	r.type_ = &type_
	return r
}

// Request timestamp (from BaseMessage)
func (r ConfigAPIGetDeviceInfoRequest) Timestamp(timestamp time.Time) ConfigAPIGetDeviceInfoRequest {
	r.timestamp = &timestamp
	return r
}

func (r ConfigAPIGetDeviceInfoRequest) Execute() (*DeviceInfoResponse, *http.Response, error) {
	return r.ApiService.GetDeviceInfoExecute(r)
}

/*
GetDeviceInfo Get device information

Query device information using DeviceInfoRequest parameters. The type parameter must be DEVICE_INFO_REQUEST to match the DeviceInfoRequest component schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId ID of the device to query (from DeviceInfoRequest)
 @return ConfigAPIGetDeviceInfoRequest
*/
func (a *ConfigAPIService) GetDeviceInfo(ctx context.Context, deviceId string) ConfigAPIGetDeviceInfoRequest {
	return ConfigAPIGetDeviceInfoRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return DeviceInfoResponse
func (a *ConfigAPIService) GetDeviceInfoExecute(r ConfigAPIGetDeviceInfoRequest) (*DeviceInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetDeviceInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetDeviceInterfacesRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
}

func (r ConfigAPIGetDeviceInterfacesRequest) Execute() (*map[string]GetDeviceInterfaces200ResponseValue, *http.Response, error) {
	return r.ApiService.GetDeviceInterfacesExecute(r)
}

/*
GetDeviceInterfaces Get device interfaces configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIGetDeviceInterfacesRequest
*/
func (a *ConfigAPIService) GetDeviceInterfaces(ctx context.Context, deviceId string) ConfigAPIGetDeviceInterfacesRequest {
	return ConfigAPIGetDeviceInterfacesRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]GetDeviceInterfaces200ResponseValue
func (a *ConfigAPIService) GetDeviceInterfacesExecute(r ConfigAPIGetDeviceInterfacesRequest) (*map[string]GetDeviceInterfaces200ResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]GetDeviceInterfaces200ResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetDeviceInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetRoutingConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId *string
}

// Device identifier
func (r ConfigAPIGetRoutingConfigRequest) DeviceId(deviceId string) ConfigAPIGetRoutingConfigRequest {
	r.deviceId = &deviceId
	return r
}

func (r ConfigAPIGetRoutingConfigRequest) Execute() (*RoutingConfig, *http.Response, error) {
	return r.ApiService.GetRoutingConfigExecute(r)
}

/*
GetRoutingConfig Get Routing Configuration

Retrieve device routing configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIGetRoutingConfigRequest
*/
func (a *ConfigAPIService) GetRoutingConfig(ctx context.Context) ConfigAPIGetRoutingConfigRequest {
	return ConfigAPIGetRoutingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoutingConfig
func (a *ConfigAPIService) GetRoutingConfigExecute(r ConfigAPIGetRoutingConfigRequest) (*RoutingConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutingConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetRoutingConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/routing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetSwitchConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId *string
}

// ID of the switch
func (r ConfigAPIGetSwitchConfigRequest) DeviceId(deviceId string) ConfigAPIGetSwitchConfigRequest {
	r.deviceId = &deviceId
	return r
}

func (r ConfigAPIGetSwitchConfigRequest) Execute() (*SwitchDeviceConfig, *http.Response, error) {
	return r.ApiService.GetSwitchConfigExecute(r)
}

/*
GetSwitchConfig Get Switch Configuration

Retrieves the configuration of a network switch including features, ports, and capabilities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIGetSwitchConfigRequest
*/
func (a *ConfigAPIService) GetSwitchConfig(ctx context.Context) ConfigAPIGetSwitchConfigRequest {
	return ConfigAPIGetSwitchConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SwitchDeviceConfig
func (a *ConfigAPIService) GetSwitchConfigExecute(r ConfigAPIGetSwitchConfigRequest) (*SwitchDeviceConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SwitchDeviceConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetSwitchConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetSystemSettingsRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
}

func (r ConfigAPIGetSystemSettingsRequest) Execute() (*GetSystemSettings200Response, *http.Response, error) {
	return r.ApiService.GetSystemSettingsExecute(r)
}

/*
GetSystemSettings Get system settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIGetSystemSettingsRequest
*/
func (a *ConfigAPIService) GetSystemSettings(ctx context.Context, deviceId string) ConfigAPIGetSystemSettingsRequest {
	return ConfigAPIGetSystemSettingsRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return GetSystemSettings200Response
func (a *ConfigAPIService) GetSystemSettingsExecute(r ConfigAPIGetSystemSettingsRequest) (*GetSystemSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSystemSettings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetSystemSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/system"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIGetVlanConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	vlanId *int32
}

// VLAN identifier
func (r ConfigAPIGetVlanConfigRequest) VlanId(vlanId int32) ConfigAPIGetVlanConfigRequest {
	r.vlanId = &vlanId
	return r
}

func (r ConfigAPIGetVlanConfigRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.GetVlanConfigExecute(r)
}

/*
GetVlanConfig Get VLAN Configuration

Retrieve VLAN configuration details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIGetVlanConfigRequest
*/
func (a *ConfigAPIService) GetVlanConfig(ctx context.Context) ConfigAPIGetVlanConfigRequest {
	return ConfigAPIGetVlanConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *ConfigAPIService) GetVlanConfigExecute(r ConfigAPIGetVlanConfigRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.GetVlanConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vlanId == nil {
		return localVarReturnValue, nil, reportError("vlanId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "vlanId", r.vlanId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIPutRoutingConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	routingConfig *RoutingConfig
	ifMatch *string
}

// Routing configuration details
func (r ConfigAPIPutRoutingConfigRequest) RoutingConfig(routingConfig RoutingConfig) ConfigAPIPutRoutingConfigRequest {
	r.routingConfig = &routingConfig
	return r
}

// ETag for optimistic concurrency control
func (r ConfigAPIPutRoutingConfigRequest) IfMatch(ifMatch string) ConfigAPIPutRoutingConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ConfigAPIPutRoutingConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutRoutingConfigExecute(r)
}

/*
PutRoutingConfig Update Routing Configuration

Update device routing configuration including static routes and routing protocols

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIPutRoutingConfigRequest
*/
func (a *ConfigAPIService) PutRoutingConfig(ctx context.Context) ConfigAPIPutRoutingConfigRequest {
	return ConfigAPIPutRoutingConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigAPIService) PutRoutingConfigExecute(r ConfigAPIPutRoutingConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.PutRoutingConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/routing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routingConfig == nil {
		return nil, reportError("routingConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.routingConfig
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v IdempotencyConflictError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIRequestBulkDeviceInfoRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	requestBulkDeviceInfoRequest *RequestBulkDeviceInfoRequest
}

func (r ConfigAPIRequestBulkDeviceInfoRequest) RequestBulkDeviceInfoRequest(requestBulkDeviceInfoRequest RequestBulkDeviceInfoRequest) ConfigAPIRequestBulkDeviceInfoRequest {
	r.requestBulkDeviceInfoRequest = &requestBulkDeviceInfoRequest
	return r
}

func (r ConfigAPIRequestBulkDeviceInfoRequest) Execute() (*map[string]DeviceInfoResponse, *http.Response, error) {
	return r.ApiService.RequestBulkDeviceInfoExecute(r)
}

/*
RequestBulkDeviceInfo Request information for multiple devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIRequestBulkDeviceInfoRequest
*/
func (a *ConfigAPIService) RequestBulkDeviceInfo(ctx context.Context) ConfigAPIRequestBulkDeviceInfoRequest {
	return ConfigAPIRequestBulkDeviceInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]DeviceInfoResponse
func (a *ConfigAPIService) RequestBulkDeviceInfoExecute(r ConfigAPIRequestBulkDeviceInfoRequest) (*map[string]DeviceInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]DeviceInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.RequestBulkDeviceInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/info/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBulkDeviceInfoRequest == nil {
		return localVarReturnValue, nil, reportError("requestBulkDeviceInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBulkDeviceInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIRequestDeviceInfoRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	deviceInfoRequest *DeviceInfoRequest
}

func (r ConfigAPIRequestDeviceInfoRequest) DeviceInfoRequest(deviceInfoRequest DeviceInfoRequest) ConfigAPIRequestDeviceInfoRequest {
	r.deviceInfoRequest = &deviceInfoRequest
	return r
}

func (r ConfigAPIRequestDeviceInfoRequest) Execute() (*DeviceInfoResponse, *http.Response, error) {
	return r.ApiService.RequestDeviceInfoExecute(r)
}

/*
RequestDeviceInfo Request device information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIRequestDeviceInfoRequest
*/
func (a *ConfigAPIService) RequestDeviceInfo(ctx context.Context, deviceId string) ConfigAPIRequestDeviceInfoRequest {
	return ConfigAPIRequestDeviceInfoRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return DeviceInfoResponse
func (a *ConfigAPIService) RequestDeviceInfoExecute(r ConfigAPIRequestDeviceInfoRequest) (*DeviceInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.RequestDeviceInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceInfoRequest == nil {
		return localVarReturnValue, nil, reportError("deviceInfoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceInfoRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIUpdateACLRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
	aCL *ACL
}

func (r ConfigAPIUpdateACLRequest) ACL(aCL ACL) ConfigAPIUpdateACLRequest {
	r.aCL = &aCL
	return r
}

func (r ConfigAPIUpdateACLRequest) Execute() (*ACL, *http.Response, error) {
	return r.ApiService.UpdateACLExecute(r)
}

/*
UpdateACL Create or update ACL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @return ConfigAPIUpdateACLRequest
*/
func (a *ConfigAPIService) UpdateACL(ctx context.Context, deviceId string, aclName string) ConfigAPIUpdateACLRequest {
	return ConfigAPIUpdateACLRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
	}
}

// Execute executes the request
//  @return ACL
func (a *ConfigAPIService) UpdateACLExecute(r ConfigAPIUpdateACLRequest) (*ACL, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ACL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateACL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aCL == nil {
		return localVarReturnValue, nil, reportError("aCL is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aCL
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIUpdateACLRuleRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	aclName string
	ruleId int32
	aCLRule *ACLRule
}

func (r ConfigAPIUpdateACLRuleRequest) ACLRule(aCLRule ACLRule) ConfigAPIUpdateACLRuleRequest {
	r.aCLRule = &aCLRule
	return r
}

func (r ConfigAPIUpdateACLRuleRequest) Execute() (*ACLRule, *http.Response, error) {
	return r.ApiService.UpdateACLRuleExecute(r)
}

/*
UpdateACLRule Update ACL rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param aclName
 @param ruleId
 @return ConfigAPIUpdateACLRuleRequest
*/
func (a *ConfigAPIService) UpdateACLRule(ctx context.Context, deviceId string, aclName string, ruleId int32) ConfigAPIUpdateACLRuleRequest {
	return ConfigAPIUpdateACLRuleRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		aclName: aclName,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return ACLRule
func (a *ConfigAPIService) UpdateACLRuleExecute(r ConfigAPIUpdateACLRuleRequest) (*ACLRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ACLRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateACLRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/acls/{deviceId}/{aclName}/rules/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aclName"+"}", url.PathEscape(parameterValueToString(r.aclName, "aclName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aCLRule == nil {
		return localVarReturnValue, nil, reportError("aCLRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aCLRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIUpdateDeviceConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	deviceConfigUpdateMessage *DeviceConfigUpdateMessage
}

func (r ConfigAPIUpdateDeviceConfigRequest) DeviceConfigUpdateMessage(deviceConfigUpdateMessage DeviceConfigUpdateMessage) ConfigAPIUpdateDeviceConfigRequest {
	r.deviceConfigUpdateMessage = &deviceConfigUpdateMessage
	return r
}

func (r ConfigAPIUpdateDeviceConfigRequest) Execute() (*DeviceSettings, *http.Response, error) {
	return r.ApiService.UpdateDeviceConfigExecute(r)
}

/*
UpdateDeviceConfig Update device configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIUpdateDeviceConfigRequest
*/
func (a *ConfigAPIService) UpdateDeviceConfig(ctx context.Context, deviceId string) ConfigAPIUpdateDeviceConfigRequest {
	return ConfigAPIUpdateDeviceConfigRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return DeviceSettings
func (a *ConfigAPIService) UpdateDeviceConfigExecute(r ConfigAPIUpdateDeviceConfigRequest) (*DeviceSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateDeviceConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceConfigUpdateMessage == nil {
		return localVarReturnValue, nil, reportError("deviceConfigUpdateMessage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceConfigUpdateMessage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigAPIUpdateInterfaceConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	interfaceId string
	getDeviceInterfaces200ResponseValue *GetDeviceInterfaces200ResponseValue
}

func (r ConfigAPIUpdateInterfaceConfigRequest) GetDeviceInterfaces200ResponseValue(getDeviceInterfaces200ResponseValue GetDeviceInterfaces200ResponseValue) ConfigAPIUpdateInterfaceConfigRequest {
	r.getDeviceInterfaces200ResponseValue = &getDeviceInterfaces200ResponseValue
	return r
}

func (r ConfigAPIUpdateInterfaceConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateInterfaceConfigExecute(r)
}

/*
UpdateInterfaceConfig Update interface configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @param interfaceId
 @return ConfigAPIUpdateInterfaceConfigRequest
*/
func (a *ConfigAPIService) UpdateInterfaceConfig(ctx context.Context, deviceId string, interfaceId string) ConfigAPIUpdateInterfaceConfigRequest {
	return ConfigAPIUpdateInterfaceConfigRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
func (a *ConfigAPIService) UpdateInterfaceConfigExecute(r ConfigAPIUpdateInterfaceConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateInterfaceConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getDeviceInterfaces200ResponseValue == nil {
		return nil, reportError("getDeviceInterfaces200ResponseValue is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getDeviceInterfaces200ResponseValue
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIUpdateSwitchConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	switchDeviceConfig *SwitchDeviceConfig
}

// Switch configuration update
func (r ConfigAPIUpdateSwitchConfigRequest) SwitchDeviceConfig(switchDeviceConfig SwitchDeviceConfig) ConfigAPIUpdateSwitchConfigRequest {
	r.switchDeviceConfig = &switchDeviceConfig
	return r
}

func (r ConfigAPIUpdateSwitchConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSwitchConfigExecute(r)
}

/*
UpdateSwitchConfig Update Switch Configuration

Updates the configuration of a network switch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIUpdateSwitchConfigRequest
*/
func (a *ConfigAPIService) UpdateSwitchConfig(ctx context.Context) ConfigAPIUpdateSwitchConfigRequest {
	return ConfigAPIUpdateSwitchConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigAPIService) UpdateSwitchConfigExecute(r ConfigAPIUpdateSwitchConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateSwitchConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.switchDeviceConfig == nil {
		return nil, reportError("switchDeviceConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.switchDeviceConfig
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIUpdateSystemSettingsRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	deviceId string
	getSystemSettings200Response *GetSystemSettings200Response
}

func (r ConfigAPIUpdateSystemSettingsRequest) GetSystemSettings200Response(getSystemSettings200Response GetSystemSettings200Response) ConfigAPIUpdateSystemSettingsRequest {
	r.getSystemSettings200Response = &getSystemSettings200Response
	return r
}

func (r ConfigAPIUpdateSystemSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSystemSettingsExecute(r)
}

/*
UpdateSystemSettings Update system settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId
 @return ConfigAPIUpdateSystemSettingsRequest
*/
func (a *ConfigAPIService) UpdateSystemSettings(ctx context.Context, deviceId string) ConfigAPIUpdateSystemSettingsRequest {
	return ConfigAPIUpdateSystemSettingsRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *ConfigAPIService) UpdateSystemSettingsExecute(r ConfigAPIUpdateSystemSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateSystemSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/devices/{deviceId}/system"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getSystemSettings200Response == nil {
		return nil, reportError("getSystemSettings200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSystemSettings200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigAPIUpdateVlanConfigRequest struct {
	ctx context.Context
	ApiService ConfigAPI
	vLAN *VLAN
	ifMatch *string
}

// VLAN configuration details
func (r ConfigAPIUpdateVlanConfigRequest) VLAN(vLAN VLAN) ConfigAPIUpdateVlanConfigRequest {
	r.vLAN = &vLAN
	return r
}

// ETag for optimistic concurrency control
func (r ConfigAPIUpdateVlanConfigRequest) IfMatch(ifMatch string) ConfigAPIUpdateVlanConfigRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ConfigAPIUpdateVlanConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVlanConfigExecute(r)
}

/*
UpdateVlanConfig Update VLAN Configuration

Update existing VLAN configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigAPIUpdateVlanConfigRequest
*/
func (a *ConfigAPIService) UpdateVlanConfig(ctx context.Context) ConfigAPIUpdateVlanConfigRequest {
	return ConfigAPIUpdateVlanConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigAPIService) UpdateVlanConfigExecute(r ConfigAPIUpdateVlanConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigAPIService.UpdateVlanConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/vlan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLAN == nil {
		return nil, reportError("vLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "simple", "")
	}
	// body params
	localVarPostBody = r.vLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["configAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
